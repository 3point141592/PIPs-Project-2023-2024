= Page =

= Toolbox =

= Search =

= P versus NP =
 $ P $   versus   $ NP $  is one of the greatest computability and complexity problems of modern mathematics, and one of the Millennium Problems .  $ P $  the class of decision problems (those whose answer is either "yes" or "no," as opposed to other classes such as counting problems) that can be solved by a deterministic algorithm in polynomial time.  $ NP $  is the class of decision problems that can be solved by a non-deterministic algorithm in polynomial time.  The  $ P $  versus  $ NP $  question asks whether these two classes are the same, or whether there are problems in  $ NP $  that are not in  $ P $  . Since all modern computers (with the exception of a few quantum computers) are deterministic, non-deterministic algorithms are of theoretical, rather than practical, interest.  However, the class  $ NP $  can also be defined without reference to nondeterminism: This article is a stub.  Help us out by  .  
== Contents ==

== Overview ==
The relation between the complexity classes  $ P $  and  $ NP $  is one of the most important open problems in theoretical computer science and mathematics . The most common measurements are time (how many steps it takes to solve a problem as a function of input, usually expressed with big-O notation) and space (how much memory it takes to solve a problem). In such analysis, a model of the computer for which time must be analyzed is required. Typically, such models assume that the computer is deterministic - that, given the computer's present state and any inputs, there is only one possible action that the computer might take - and sequential - it performs actions one after the other, such as a deterministic Turing machine. These assumptions reflect the behaviour of all practical computers yet devised, even including machines featuring parallel processing . A decision problem is a problem that admits a yes or no answer (as opposed to an optimization problem, such as "What is the length of the longest path from  $ s $  to  $ t $  ?"). More formally, a decision problem may be thought of as a language  $ L $  for which we wish to decide if a given word  $ w $  belongs to the language. We say that an algorithm  $ A $   decides a language  $ L $  if, for all inputs  $ w $  ,  $ A $  either accepts or rejects  $ w $  . 
=== The class P ===
The class  $ P $  consists of all those decision problems (languages) that can be decided using a deterministic Turing machine in an amount of time that is polynomial in the size of the input. More formally,  $ P = \bigcup_{k \ge 0} \text{TIME}(O(n^k)) $  where  $ \text{TIME}(f(n)) $  is the set of languages decidable by an  $ O(f(n)) $  -time deterministic Turing machine. 
=== The class NP ===
The class  $ NP $  (for non-deterministic polynomial time ) consists of all those decision problems that are decidable using a non-deterministic Turing machine . It is equivalent to the set of decision problems for which whose yes instances are efficiently verifiable in polynomial time using a certificate. Examples of problems in  $ P $  and  $ NP $  are given below. 
== Importance ==
Arguably, the biggest open question in theoretical computer science concerns the relationship between those two classes: Is  $ P $  equal to  $ NP $  ? In a 2002 poll of 100 researchers, 61 believed the answer is no, 9 believed the answer is yes, 22 were unsure, and 8 believed the question may be independent of the currently accepted axioms, and so impossible to prove or disprove. The Clay Mathematics Institute has offered a USD $1,000,000 prize for a correct solution, as it has listed it as one of its Millennium Problems . 
== Arguments ==
It is easy to show that  $ P \subseteq NP $  , as if we are given any  $ L \in P $  , a polynomial-time verifier for  $ L $  , given input  $ w $  and a certificate  $ c $  , can simply ignore the certificate and decide if  $ w \in L $  . An important role in this discussion is played by the set of  $ NP $  -complete problems (or  $ NPC $  ) which can be loosely described as the hardest problems in  $ NP $  . More precisely, a language  $ L $  is NP-complete if both are true: The main idea behind a polynomial-time reduction is this: If we knew how to decide  $ L $  in polynomial time, then any problem in  $ NP $  can be converted into an instance of  $ L $  in polynomial time, and then we can use the algorithm that decides  $ L $  as a subroutine. 
=== Examples of P, NP, NP-complete problems ===
The following problems are examples of problems in  $ P $  (i.e. ones we can answer in polynomial time as a function of input): A classic example of a problem that is  $ NP $  -complete but not known to be in  $ P $  is the subset sum problem : Given a list  $ S $  of  $ n $  integers and a number  $ t $  , all encoded in some base  $ b > 1 $  , is there some subset of numbers in  $ S $  whose sum is  $ t $  ? For example, is there a subset of  $ \{-4,2,3,10,-8,7\} $  whose sum is 14? The answer is yes, and it can be checked in polynomial time that the answer is yes (by giving the certificate  $ \{2,3,10,-8,7\} $  , but this is a difficult problem to solve in general as a brute force solution requires  $ O(2^n n) $  computations, and it is not known if subset sum is in  $ P $  . The following examples are NP-complete problems: The restriction to  $ YES/NO $  problems doesn't really make a difference; even if we allow more complicated answers, the resulting problem (whether  $ FP = FNP $  ) is equivalent. Something appears to not have loaded correctly. Click to refresh .